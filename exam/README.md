<h1><p align="center"><strong>Екзаменаційна робота</strong></p>
<p align="center"><strong>З дисципліни «Тестування програмних систем та комплексів»</strong></p>
<p align="center"><strong>Студента групи КН-340</strong></p>
<p align="center"><strong>Вишинський Назар</strong></p></h1>

# Білет №3

## 1. Різниця між верифікацією та валідацією програмного забезпечення

### **Верифікація (Verification)**:
- **Що це?** Процес, який відповідає на запитання: "Чи правильно ми створюємо продукт?"
- **Ціль:** Перевірити відповідність результату розробки специфікаціям та вимогам.
- **Етап:** Виконується на кожному етапі розробки, щоб забезпечити коректність.
- **Приклад:** Перегляд вихідного коду (`code review`), тестування модулів.

### **Валідація (Validation)**:
- **Що це?** Процес, який відповідає на запитання: "Чи створюємо ми правильний продукт?"
- **Ціль:** Переконатися, що кінцевий продукт відповідає очікуванням користувача.
- **Етап:** Виконується після завершення розробки.
- **Приклад:** Тестування всього продукту, приймальне тестування (`acceptance testing`).

**Коротко:** Верифікація фокусується на створенні програмного продукту згідно вимог, а валідація — на підтвердженні відповідності кінцевого продукту очікуванням.

---

## 2. Конструкція `assert` у Python

**`assert`** — це інструмент для перевірки відповідності виконання коду певним умовам під час розробки або тестування. Якщо умова не виконується, викликається виключення `AssertionError`.

### **Синтаксис**:
```python
assert condition, message
```
- **`condition`**: Умова, яку необхідно перевірити.
- **`message`** (необов’язково): Повідомлення, що описує помилку.

### **Приклад використання у тестах**:
```python
# Перевірка роботи функції
def add(a, b):
    return a + b

assert add(2, 3) == 5, "Результат має бути 5"
assert add(-1, 1) == 0, "Результат має бути 0"
```

### **Примітка:**
`assert` використовується у тестах або для знаходження помилок під час розробки, але не в продуктивному коді. У бойових середовищах використання `assert` може бути вимкнено параметрами інтерпретатора Python.

---

## 3. Що таке CI/CD (Continuous Integration / Continuous Delivery) і як автоматичні тести інтегруються в цей процес?

### **CI (Continuous Integration)**:
- Автоматичний процес збирання програмного продукту кожного разу, коли розробник додає нові зміни у репозиторій.
- **Мета:** Верифікувати, що зміни у коді не ламають існуючу функціональність.
- **Інтеграція тестів:** Автоматичні модульні, інтеграційні тести виконуються під час кожного коміту або створення pull request.

### **CD (Continuous Delivery)**:
- Автоматичний процес підготовки змін до розгортання у бойове середовище.
- **Мета:** Забезпечити готовність нових версій продукту до випуску.
- **Інтеграція тестів:** Включає додаткові перевірки (системні, приймальні тести), перш ніж зміни стануть доступними користувачам.

### **Переваги включення тестів у CI/CD**:
1. Швидке знаходження і виправлення помилок.
2. Гарантія, що нові зміни не ламають існуючий код.
3. Підтримка стабільності та надійності програмного забезпечення.

**Популярні інструменти для CI/CD:** GitHub Actions, Jenkins, GitLab CI/CD.

---

## 4. Практична частина

### Завдання

Реалізуйте функцію `factorial(n: int)`, яка обчислює факторіал числа. У випадку, якщо `n` є від’ємним числом, функція має викликати `ValueError`.

---

### Файл `main.py`
```python
def factorial(n: int) -> int:
    """
    Обчислення факторіалу числа.

    :param n: Невід'ємне ціле число
    :return: Факторіал числа
    """
    if n < 0:
        raise ValueError("Факторіал для від'ємних чисел не визначено")
    if n == 0 or n == 1:
        return 1
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result
```

---

### Файл `test.py`
```python
import unittest
from main import factorial

class TestFactorial(unittest.TestCase):
    def test_positive_numbers(self):
        # Тестуємо факторіал для позитивних чисел
        self.assertEqual(factorial(0), 1)
        self.assertEqual(factorial(1), 1)
        self.assertEqual(factorial(5), 120)
        self.assertEqual(factorial(6), 720)

    def test_negative_numbers(self):
        # Тестуємо некоректний ввід (від'ємні числа)
        with self.assertRaises(ValueError):
            factorial(-1)
        with self.assertRaises(ValueError):
            factorial(-10)

    def test_large_numbers(self):
        # Тестуємо факторіал для великих входів
        self.assertEqual(factorial(10), 3628800)

if __name__ == "__main__":
    unittest.main()

```
